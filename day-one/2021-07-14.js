// 给你两个正整数数组 nums1 和 nums2 ，数组的长度都是 n 。
// 数组 nums1 和 nums2 的 绝对差值和 定义为所有 |nums1[i] - nums2[i]|（0 <= i < n）的 总和（下标从 0 开始）。
// 你可以选用 nums1 中的 任意一个 元素来替换 nums1 中的 至多 一个元素，以 最小化 绝对差值和。
// 在替换数组 nums1 中最多一个元素 之后 ，返回最小绝对差值和。因为答案可能很大，所以需要对 109 + 7 取余 后返回。
// |x| 定义为：
// 如果 x >= 0 ，值为 x ，或者
// 如果 x <= 0 ，值为 -x

// 示例 1：
// 输入：nums1 = [1,7,5], nums2 = [2,3,5]
// 输出：3
// 解释：有两种可能的最优方案：
// - 将第二个元素替换为第一个元素：[1,7,5] => [1,1,5] ，或者
// - 将第二个元素替换为第三个元素：[1,7,5] => [1,5,5]
// 两种方案的绝对差值和都是 |1-2| + (|1-3| 或者 |5-3|) + |5-5| = 3

// 示例 2：
// 输入：nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]
// 输出：0
// 解释：nums1 和 nums2 相等，所以不用替换元素。绝对差值和为 0

// 示例 3：
// 输入：nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]
// 输出：20
// 解释：将第一个元素替换为第二个元素：[1,10,4,4,2,7] => [10,10,4,4,2,7]
// 绝对差值和为 |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20


// 二分
// 这是一道二分陈题，具体做法如下：

// 我们在进行处理前，先对 nums1 进行拷贝并排序，得到 sorted 数组。

// 然后 在遍历 nums1 和 nums2 计算总的差值 sum 时，通过对 sorted 进行二分查找，找到最合适替换 nums[i] 的值。

// 具体的，当我们处理到第 i 位时，假设该位的原差值为 x=abs(nums1[i]−nums2[i])，然后从 sorted 数组中通过二分找到最接近 nums2[i] 的值，计算一个新的差值 nd（注意要检查分割点与分割点的下一位），如果满足 nd < x 说明存在一个替换方案使得差值变小，我们使用变量 max 记下来这个替换方案所带来的变化，并不断更新 max。

// 当整个数组被处理完，max 存储着最优方案对应的差值变化，此时 sum - max 即是答案。

/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 * 
 * 错误思路：最初以为是替换最大的值即可， 其实不是的， 比如例子[1, 28, 21], [9, 21, 20], 差值为[8, 7, 1]， 如果按照最初的想法， 替换差值最大的值8， 其实最后的结果依旧是8 + 7 + 1 = 16， 但其实28可以替换为21， 此时为差值为9
 * 
 * 正确思路：既然不是最大值，那么应该在每一个nums2[i]值的时候，查找在nums1中差值最小的值。由于最多可以替换一个，所以，需要和上一个差值比较，留小者
 */
var minAbsoluteSumDiff = function (nums1, nums2) {
  const MOD = 1000000007;
  const len = nums1.length;
  let sorted = [...nums1];
  sorted.sort((a, b) => a - b);

  // 最后差值和，以及最大的差值更改
  let sum = 0,
    max = 0;

  for (let i = 0; i < len; i++) {
    let a = nums1[i],
      b = nums2[i];
    if (a == b) continue;

    let x = Math.abs(a - b);
    sum += x; // 计算当前差值和

    let left = 0,
      right = len - 1; // 二分查找到 当前值 nums2[i] 在 nums1 中的最接近的值
    while (left < right) {
      let mid = left + right + 1 >> 1;
      if (sorted[mid] <= b) {
        left = mid;
      } else {
        right = mid - 1;
      }
    }

    let nd = Math.abs(sorted[right] - b);
    if (right + 1 < len) nd = Math.min(nd, Math.abs(sorted[right + 1] - b));
    if (nd < x) max = Math.max(max, x - nd); // 更换最大差值
  }
  return ((sum - max) % MOD);
};

console.log(minAbsoluteSumDiff([1, 28, 21], [9, 21, 20]))
console.log('minAbsoluteSumDiff', minAbsoluteSumDiff([57, 42, 21, 28, 30, 25, 22, 12, 55, 3, 47, 18, 43, 29, 20, 44, 59, 9, 43, 7, 8, 5, 42, 53, 99, 34, 37, 88, 87, 62, 38, 68, 31, 3, 11, 61, 93, 34, 63, 27, 20, 48, 38, 5, 71, 100, 88, 54, 52, 15, 98, 59, 74, 26, 81, 38, 11, 44, 25, 69, 79, 81, 51, 85, 59, 84, 83, 99, 31, 47, 31, 23, 83, 70, 82, 79, 86, 31, 50, 17, 11, 100, 55, 15, 98, 11, 90, 16, 46, 89, 34, 33, 57, 53, 82, 34, 25, 70, 5, 1],
  [76, 3, 5, 29, 18, 53, 55, 79, 30, 33, 87, 3, 56, 93, 40, 80, 9, 91, 71, 38, 35, 78, 32, 58, 77, 41, 63, 5, 21, 67, 21, 84, 52, 80, 65, 38, 62, 99, 80, 13, 59, 94, 21, 61, 43, 82, 29, 97, 31, 24, 95, 52, 90, 92, 37, 26, 65, 89, 90, 32, 27, 3, 42, 47, 93, 25, 14, 5, 39, 85, 89, 7, 74, 38, 12, 46, 40, 25, 51, 2, 19, 8, 21, 62, 58, 29, 32, 77, 62, 9, 74, 98, 10, 55, 25, 62, 48, 48, 24, 21]))
console.log('minAbsoluteSumDiff', minAbsoluteSumDiff([2, 4, 6, 8, 10], [2, 4, 6, 8, 10]))
console.log('minAbsoluteSumDiff', minAbsoluteSumDiff([1, 10, 4, 4, 2, 7], [9, 3, 5, 1, 7, 4]))
