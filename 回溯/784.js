// 给定一个字符串S， 通过将字符串S中的每个字母转变大小写， 我们可以获得一个新的字符串。 返回所有可能得到的字符串集合。
// 示例：
// 输入： S = "a1b2"
// 输出：["a1b2", "a1B2", "A1b2", "A1B2"]

// 输入： S = "3z4"
// 输出：["3z4", "3Z4"]

// 输入： S = "12345"
// 输出：["12345"]
/**
 * 这一类搜索问题是在一个隐式的树上进行的搜索问题， 即「 树形问题」。 解决这一类问题， 先画出递归树是十分重要的， 可以帮助打开思路， 然后看着图形把代码写出来；
 这个问题所求的解， 是这棵树的叶子结点上的值。 因此， 可以使用深度优先遍历， 收集 所有 叶子结点的值， 深度优先遍历用于搜索也叫回溯算法；
 回溯算法因为有回头的过程， 因此其显著特征是 状态重置。 回溯算法的入门问题是「 力扣」 第 46 题： 全排列）。

 * @param {string} S
 * @return {string[]}
 */
var letterCasePermutation = function (S) {
  // 深度优先
};
