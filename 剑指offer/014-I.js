// 给你一根长度为 n 的绳子， 请把绳子剪成整数长度的 m 段（ m、 n都是整数， n > 1 并且m > 1）， 每段绳子的长度记为 k[0], k[1]...k[m - 1]。 请问 k[0] * k[1] * ... * k[m - 1] 可能的最大乘积是多少？ 例如， 当绳子的长度是8时， 我们把它剪成长度分别为2、 3、 3 的三段， 此时得到的最大乘积是18。
// 输入: 2
// 输出: 1
// 解释: 2 = 1 + 1, 1× 1 = 1
// 示例 2:

//   输入: 10
// 输出: 36
// 解释: 10 = 3 + 3 + 4, 3× 3× 4 = 36

/**
 * 动态规划：首先确定状态转移方程
 * - 首先用一个数组表示 [0, i] 时的最大乘积，dp[2] = 1;(数组前两个 0，1 其实是不存在的，因为 n > 1,m > 1)
 * - 此时开始剪绳子 m 长度， m = 1 时，是无增益的，所以从 m = 2 开始；
 * - 剪下第一段时，有两种情况，剩余的 i - m 可以选择不继续剪，或者选择继续剪，所以取两者中最大值。
 *     - 如果不剪掉的话，此时最大乘积为 m * (i - m)；
 *     - 如果剪掉的话，此时最大乘积为 m * dp[i - m] (这里dp[i - m]代表的是，i -m 处最大乘积，乘以当前 m ，可得当前全部最大乘积)。
 * - 在每一次剪绳子中，有可能得到的结果比上一次尝试的长度 m 更小，所以需要对每一次 m 的尝试取最大值。
 * 
 * 时间复杂度: O(n ^ 2)
 * @param {number} n
 * @return {number}
 */
var cuttingRope = function (n) {
  let dp = [0, 0, 1];
  for (let i = 3; i <= n; i++) {
    let curMax = 0;
    for (let m = 2; m < i; m++) {
      curMax = Math.max(curMax, Math.max(m * (i - m), m * dp[i - m]));
    }
    dp[i] = curMax;
  }
  return dp[n];
};

/**
 * 贪心：尽可能的制造多个3，结束循环条件是 剩余长度 > 4，（经验可得）
 * 当 n = 2 时，res = 1, n = 3, res = 2,得，n < 4 时，res = n - 1;
 * 
 * 时间复杂度: O(n)
 * @param {*} n 
 */
let cuttingRope1 = function (n) {
  if (n < 4) {
    return n - 1;
  }
  let res = 1;
  while (n > 4) {
    res *= 3;
    n -= 3;
  }
  return res * n;
}
console.log('cut', cuttingRope(10))
